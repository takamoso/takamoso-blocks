import fs from 'fs'
import rimraf from 'rimraf'
import path from 'path'
import gulp from 'gulp'
import sass from 'gulp-sass'
import postcss from 'gulp-postcss'
import autoprefixer from 'autoprefixer'
import cssnano from 'cssnano'
import webpack from 'webpack'
import webpackMerge from 'webpack-merge'
import webpackStream from 'webpack-stream'
import uglifyJSPlugin from 'uglifyjs-webpack-plugin'
import prism_components from 'prismjs/components'

const config = {}

config.common = {
  entry: {
    editor: path.join(__dirname, 'src/editor.js'),
    front: path.join(__dirname, 'src/front.js')
  },
  output: {
    filename: '[name].js'
  },
  module: {
    rules: [{
      test: /.js$/,
      exclude: /node_modules/,
      use: [{
        loader: 'babel-loader',
        options: {
          babelrc: false,
          presets: [
            ['@babel/preset-env', {
              modules: false,
              useBuiltIns: 'usage'
            }]
          ],
          plugins: [
            ['@babel/plugin-transform-react-jsx', {
              pragma: 'wp.element.createElement'
            }]
          ]
        }
      }]
    }]
  }
}

config.dev = webpackMerge(config.common, {
  mode: 'development',
  plugins: [
    new webpack.DefinePlugin({
      ENV: "'development'"
    })
  ]
})

config.prod = webpackMerge(config.common, {
  mode: 'production',
  optimization: {
    minimizer: [
      new uglifyJSPlugin({
        uglifyOptions: {
          output: {
            comments: /^!|@preserve|@license|@cc_on|@author/
          }
        }
      })
    ]
  }
})

export const style = () => {
  return gulp.src('src/!(_)*.scss')
    .pipe(sass())
    .pipe(postcss([
      autoprefixer({
        grid: true
      }),
      cssnano()
    ]))
    .pipe(gulp.dest('./'))
}

export const script = env => {
  return function script() {
    return webpackStream(env, webpack)
      .pipe(gulp.dest('./'))
  }
}

export const prism = callback => {
  const map = {}
  
  Object.keys(prism_components.languages).forEach(language => {
    if (language === 'meta' || ~language.indexOf('-extras')) {
      return
    }

    let lang = language
    let i = -1
    let obj = {}
    let arr = []

    if (prism_components.languages.hasOwnProperty(`${lang}-extras`)) {
      lang = `${lang}-extras`
    }

    !function getDependencies(language) {
      let dependencies = prism_components.languages[language].require

      if (dependencies) {
        if (!Array.isArray(dependencies)) {
          dependencies = [dependencies]
        }

        dependencies.forEach(value => {
          i++
          obj[value] = i
          getDependencies(value)
        })
      }
    }(lang)

    Object.keys(obj).forEach(key => arr[obj[key]] = key)

    map[language] = arr.filter(Boolean).reverse().concat(lang)
  })

  fs.writeFile(path.join(__dirname, 'src/code/languages.js'), `// Generated by \`npx gulp prism\`\nexport default ${JSON.stringify(map)}`, callback)

  return gulp.src('node_modules/prismjs/components/*.min.js', {base: 'node_modules/prismjs/components'})
    .pipe(gulp.dest('prism-components'))
}

export const build = done => {
  gulp.series(gulp.parallel(style, script(config.prod), prism), function clean(done) {
    rimraf('./dist/takamoso-blocks', done)
  }, function copy() {
    return gulp.src([
        '**/*',
        '!*(src|dist|node_modules)/**/*',
        '!*.json',
        '!gulpfile.babel.js',
        '!.*'
      ], {nodir: true})
      .pipe(gulp.dest('dist/takamoso-blocks'))
  })(done)
}

export const watch = () => {
  gulp.watch('src/**/*.scss', gulp.series(style))
  gulp.watch('src/**/*.js', gulp.series(script(config.dev)))
}